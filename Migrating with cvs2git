[[Category:Anacode]] [[Category:Version Control]]
This page sprouted from [[Anacode: Version Control]] in order to document the process after the fact.

== Successes ==
* Migration of <tt>ensembl-otter</tt> from {{ecvs|ensembl-otter/}} to {{git|anacode/ensembl-otter}}
* Imports of other ensembl modules - these are for our internal (read-only) use.  Many have branch structure problems imported from CVS.
* Some smaller subprojects from Anacode CVS


== Migration recipe ==
(incomplete - this is a reconstruction of what we did)

# Select an importer to generate a Git repository from your old history.
#* You could omit this and start with one Git commit containing the most recent state at import time.
#*: Throwing away history like this, or making it very difficult to access across the VCS type boundary, is likely to make future maintenance difficult.
#*: It is difficult to patch up the history later.
# Be clear about what you lose, that CVS provides.  Many of these neat tricks turn out to be not such a good idea in use, anyway.
#* Ease of mixing multiple projects in one repository.
#* Ability to compose a set of these subprojects via <tt>CVSROOT/modules</tt>
#* Some attempt to track where checkouts have been scattered, via <tt>CVSROOT/history</tt>
#* Easy substitution of keywords in source files
#* Appending of commit-comment text to affected files via <tt>$Log$</tt>
#* Ability to quietly rewrite history without making a commit.  Git explicitly supports history rewrite, and explicitly prevents "silent" history rewrite ''aka.'' corruption.
#* Apparent atomicity of commits between subprojects (even different repositories?).
#*: Older CVS commits were never atomic, but importers can patch them up so they looked like they were.  Heuristics are used.
#*: Newer CVS commits have a commitid field, visible in <tt>cvs log</tt> output.
#*: If two CVS modules (directories) are transferred to separate Git repositories, atomicity of commits between them is lost.  This can (has in our experience) caused deployment problems.
#*:* ''e.g.'' a modules and its calling scripts having the meaning of some variable changed, but only one of them being deployed.
#*: Git supports the notion of submodules, as a nesting of repositories.  These can record simultaneous state of multiple projects, ''but I haven't found them very practical. -- mca''
# (If the CVS repository contains multiple sub-projects), choose one or two to extract as Git repositories.  Bear in mind
#* The issues of breaking atomic commits
#* Whether it would be meaningful to make a branch or tag covering all sub-projects.  If you have existing CVS branches or tags which cover a subset of the files present at the time, ask what this means for the relationship of those files across those set boundaries.
# Perform a trial import.
#* Expect to be doing many of these and start automating things.
#* Look at the result with <tt>gitk</tt> and run some diffs against CVS checkouts.
#* Check the branches and tags.  There should be 1:1 correspondence, except for MAIN ''vs.'' master.
#* Expect to find that your project's [[#CVS history is broken]].
# Grow the import process into a script which can perform in a repeatable way.
#* Put it on a crontab.  Fresh CVS commits should then start appearing in a Git repository automatically.
#* Full import & checking runs may take 30 minutes.  This may be reduced by some caching.
# Run with both systems for a while, '''considering CVS to be the master'''.
#: For early adopters,
#:# build commits in Git
#:# squash or otherwise commit them to CVS, being careful to watch the outgoing diffs to avoid accidental reverts.
#:# wait for the importer to re-run
#:# <tt>git pull --rebase</tt> or similar, to rebase your un-pushed commits onto the latest CVS.
#: You should find that your "pushed" Git commits disappear from the rebased branch.  This works almost as well as the <tt>git-svn</tt> workflow.
#:* beware merges and branches.  ''We stuck to linear -- mca''
#:* start replacing any CVS-dependent machinery in the project.
#: For late adopters,
#:* Ensure you can clone the new repositories, commit and push.
#:* Look at the shiny new tools. ''<tt>gitk --all</tt> is my favourite -- mca''
#: ''We ran in this state for some months. -- mca''
# While it is still in CVS, start to remove from the codebase any CVS-specific features.
#* Keyword expansion.
#* Make one last pass of fixing up execute permissions.
#*: You can change them (via commit) in Git
#*: Changing them in CVS (via chmod) will change all subsequent commitids on the next cvs2git run '''after the first appearance of that file'''.  Early adopters must rebase all following branches.
#* Stop using <tt>CVSROOT/modules</tt> .
# Stability of import - various things may cause Git branches taken off CVS history to need rebasing.
#* Changes to the import process
#* Changing the nature of the initial commit in the Git repository.
#* Fixes to permissions of CVS ,v files with chmod.
#* The historic ordering of non-atomic same-second CVS commits, as perceived by the importer.
#*: This seems to have instabilities, which we removed by making import from a hacked copy of the ,v files.
# Pick a date to throw the switch.
#* Ensure all other repository users are following, by whatever means.
#* Arrange support from Systems group, if necessary.
#* Chase down old CVS working copies and commit until "clean enough".
#*: Later, commits will be impossible.
#*: Diffs and updates will remain possible until the CVS server goes away.  You may plan to leave it up indefinitely, or keep a tarball of it "just in case".
#* Terminate as many CVS branches as possible (if any).
# Stop the cvs2git importer loop.
# Commit a prominent <tt>MOVED.txt</tt> or similar file to CVS, explaining where development is continuing.
# Make CVS read-only.
# (Optional) Separate the "CVS history" from "the future".
#* Leave the complete CVS history in one archive repository,
#*: with all branches and tags renamed into a <tt>cvs/</tt> namespace, ''e.g.'' <tt>refs/heads/cvs/humpub-branch-52</tt> .  The import wrapper does this for you.
#*: the entire repository named one level down.  Our import wrapper did this by pushing successful conversions to two places, one containing only master.
#*: made read-only after a final import run for <tt>MOVED.txt</tt>.
#* Continue working from a <tt>master</tt> branch, plus any other branches carried over, stored in another Git repository.
#*: You proceed on a relatively clean (long, but linear and uncluttered with tags) Git history.
#* It is easy to add (<tt>git fetch ancient<tt>) and remove (<tt>rm -r .git/refs/heads/cvs/</tt> or similar) refs for the old CVS history, in any Git working copy.
#* Nothing is lost, but the namespace is nicely clean.
# Git is now the primary source - migration complete.
#* Be prepared to deal with the inevitable mistakes that may be caused by adopting a new tool.  We were pleased that ours were not published to Github, due to a decision to push release branches but not master.

== Old content, to revise ==
(delivery here triggerd by mg13's imminent IGM talk)

=== Import process ===
Our [http://git.internal.sanger.ac.uk/cgi-bin/gitweb.cgi?p=anacode/team_tools.git;a=tree;f=git-importing;hb=refs/heads/master wrapper scripts] in [[Team tools]] perform repeatable imports with stable commitids, and check the contents of tags and the tips of all branches against CVS.  This process has proved fairly stable but can be disrupted by the movement of CVS tags.

Output is pushed to
[http://git.internal.sanger.ac.uk/cgi-bin/gitweb.cgi/anacode/cvs/ensembl-otter.git anacode/cvs/ensembl-otter.git] (all CVS tags and branches, no other Git pushes) and to
[http://git.internal.sanger.ac.uk/cgi-bin/gitweb.cgi/anacode/ensembl-otter.git anacode/ensembl-otter.git] (MAIN branch only, and any other Git pushes).

By keeping all CVS branches and tags under the <tt>cvs/</tt> namespace, we have a clean slate for the future but retain access to old versions.  By keeping CVS history and the Git future in separate repositories, we keep the branch list short and initial history is clear of cvs2git fixups and strange merges.

* Other tools are listed on https://git.wiki.kernel.org/index.php/Interfaces,_frontends,_and_tools#Interaction_with_other_Revision_Control_Systems
** We avoided git-cvsimport because it '''drops branches it does not understand''', such as humpub-branch-52.
** [http://cvs2svn.tigris.org/cvs2git.html cvs2git] is based on the cvs2svn importer.
** mca didn't try [http://progetti.arstecnica.it/tailor/wiki tailor].
* Other preparations and fixes we made,
** Remove dependence on keyword expansion, ''e.g.'' <tt>my $VERSION = (qw$Revision: 1.1 $)[1];</tt> and similar tricks.
** Fix -kb and executable flags.
** Find unlabelled branches and restore their branch tags.  Usually this is caused by attempting to move a branch with <tt>cvs tag -F -B -b</tt> and it cannot be done right.  These can be fixed with <tt>cvs rtag</tt> but it is fiddly.
** In some cases, apply pre-import patches to the ,v files to resolve two-commits-in-one-second ordering issues or fix up lost deltatext.

==== Actions ====
# Place a "we have moved to ..." file <tt>MOVED.txt</tt> in several of the top-level directories.  Leave other files untouched, to assist evacuation efforts with <tt>cvs up; cvs diff</tt> .
# Make the old CVS module read-only for everyone.  [[SIRT:207328]].
# Create/update deployment scripts - currently manual.
# Find and remove CVS keywords
# Find and remove explicit references to CVS
#* Mostly in POD + comments
#* Also in install/make_dist scripts.